/* tslint:disable */
/* eslint-disable */
/**
 * REST API for the localization hub project
 * The project intends to provide a way to synchronize localization files, and streamline translation processes
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Access
 */
export interface Access {
    /**
     * 
     * @type {number}
     * @memberof Access
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof Access
     */
    'projectId': number;
    /**
     * 
     * @type {number}
     * @memberof Access
     */
    'userId': number;
    /**
     * 
     * @type {number}
     * @memberof Access
     */
    'roleId': number;
    /**
     * 
     * @type {boolean}
     * @memberof Access
     */
    'revoked': boolean;
    /**
     * 
     * @type {string}
     * @memberof Access
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Access
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface AccessTokenDto
 */
export interface AccessTokenDto {
    /**
     * 
     * @type {string}
     * @memberof AccessTokenDto
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof AccessTokenDto
     */
    'server': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum BUNDLESTATUS {
    Draft = 'DRAFT',
    Submitted = 'SUBMITTED',
    ChangeRequest = 'CHANGE_REQUEST',
    Approved = 'APPROVED',
    Denied = 'DENIED'
}

/**
 * 
 * @export
 * @interface Branch
 */
export interface Branch {
    /**
     * 
     * @type {number}
     * @memberof Branch
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'key': string;
    /**
     * 
     * @type {number}
     * @memberof Branch
     */
    'projectId': number;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface Bundle
 */
export interface Bundle {
    /**
     * 
     * @type {number}
     * @memberof Bundle
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof Bundle
     */
    'issuerId'?: number;
    /**
     * 
     * @type {number}
     * @memberof Bundle
     */
    'reviewerId'?: number;
    /**
     * 
     * @type {number}
     * @memberof Bundle
     */
    'projectId': number;
    /**
     * 
     * @type {BUNDLESTATUS}
     * @memberof Bundle
     */
    'status': BUNDLESTATUS;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface ClaimTokenDto
 */
export interface ClaimTokenDto {
    /**
     * 
     * @type {string}
     * @memberof ClaimTokenDto
     */
    'access': string;
}
/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'text'?: string;
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    'userId'?: number;
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    'bundleId': number;
    /**
     * 
     * @type {BUNDLESTATUS}
     * @memberof Comment
     */
    'status'?: BUNDLESTATUS;
    /**
     * 
     * @type {boolean}
     * @memberof Comment
     */
    'resolved': boolean;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface CreateAccessDto
 */
export interface CreateAccessDto {
    /**
     * 
     * @type {number}
     * @memberof CreateAccessDto
     */
    'projectId': number;
    /**
     * 
     * @type {number}
     * @memberof CreateAccessDto
     */
    'userId': number;
    /**
     * 
     * @type {number}
     * @memberof CreateAccessDto
     */
    'roleId': number;
}
/**
 * 
 * @export
 * @interface CreateBranchDto
 */
export interface CreateBranchDto {
    /**
     * 
     * @type {string}
     * @memberof CreateBranchDto
     */
    'key': string;
    /**
     * 
     * @type {number}
     * @memberof CreateBranchDto
     */
    'projectId': number;
}
/**
 * 
 * @export
 * @interface CreateBundleDto
 */
export interface CreateBundleDto {
    /**
     * 
     * @type {string}
     * @memberof CreateBundleDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateBundleDto
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof CreateBundleDto
     */
    'projectId': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateBundleDto
     */
    'translations'?: Array<number>;
}
/**
 * 
 * @export
 * @interface CreateCommentDto
 */
export interface CreateCommentDto {
    /**
     * 
     * @type {string}
     * @memberof CreateCommentDto
     */
    'text'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateCommentDto
     */
    'bundleId': number;
    /**
     * 
     * @type {BUNDLESTATUS}
     * @memberof CreateCommentDto
     */
    'status'?: BUNDLESTATUS;
}
/**
 * 
 * @export
 * @interface CreateIdentifierDto
 */
export interface CreateIdentifierDto {
    /**
     * 
     * @type {string}
     * @memberof CreateIdentifierDto
     */
    'key': string;
    /**
     * 
     * @type {number}
     * @memberof CreateIdentifierDto
     */
    'projectId': number;
    /**
     * 
     * @type {number}
     * @memberof CreateIdentifierDto
     */
    'parentId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CreateIdentifierDto
     */
    'branchId': number;
}
/**
 * 
 * @export
 * @interface CreateInvitationDto
 */
export interface CreateInvitationDto {
    /**
     * 
     * @type {string}
     * @memberof CreateInvitationDto
     */
    'email': string;
    /**
     * 
     * @type {SERVERROLE}
     * @memberof CreateInvitationDto
     */
    'role': SERVERROLE;
}
/**
 * 
 * @export
 * @interface CreateLanguageDto
 */
export interface CreateLanguageDto {
    /**
     * 
     * @type {string}
     * @memberof CreateLanguageDto
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof CreateLanguageDto
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof CreateLanguageDto
     */
    'projectId': number;
}
/**
 * 
 * @export
 * @interface CreateProjectDto
 */
export interface CreateProjectDto {
    /**
     * 
     * @type {string}
     * @memberof CreateProjectDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateProjectDto
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface CreateReviewDto
 */
export interface CreateReviewDto {
    /**
     * 
     * @type {string}
     * @memberof CreateReviewDto
     */
    'comment'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateReviewDto
     */
    'translationId': number;
    /**
     * 
     * @type {REVIEWSTATUS}
     * @memberof CreateReviewDto
     */
    'status': REVIEWSTATUS;
}
/**
 * 
 * @export
 * @interface CreateRoleDto
 */
export interface CreateRoleDto {
    /**
     * 
     * @type {string}
     * @memberof CreateRoleDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoleDto
     */
    'description': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateRoleDto
     */
    'rights': Array<number>;
}
/**
 * 
 * @export
 * @interface CreateTokenDto
 */
export interface CreateTokenDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTokenDto
     */
    'tokenDescription'?: string;
}
/**
 * 
 * @export
 * @interface CreateTranslationDto
 */
export interface CreateTranslationDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTranslationDto
     */
    'value': string;
    /**
     * 
     * @type {number}
     * @memberof CreateTranslationDto
     */
    'identifierId': number;
    /**
     * 
     * @type {number}
     * @memberof CreateTranslationDto
     */
    'languageId': number;
}
/**
 * 
 * @export
 * @interface DeleteUserDto
 */
export interface DeleteUserDto {
    /**
     * 
     * @type {string}
     * @memberof DeleteUserDto
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface Identifier
 */
export interface Identifier {
    /**
     * 
     * @type {number}
     * @memberof Identifier
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Identifier
     */
    'key': string;
    /**
     * 
     * @type {number}
     * @memberof Identifier
     */
    'projectId': number;
    /**
     * 
     * @type {number}
     * @memberof Identifier
     */
    'userId'?: number;
    /**
     * 
     * @type {number}
     * @memberof Identifier
     */
    'parentId'?: number;
    /**
     * 
     * @type {number}
     * @memberof Identifier
     */
    'branchId': number;
    /**
     * 
     * @type {boolean}
     * @memberof Identifier
     */
    'deleted': boolean;
    /**
     * 
     * @type {string}
     * @memberof Identifier
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Identifier
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface IdentifierEntity
 */
export interface IdentifierEntity {
    /**
     * 
     * @type {number}
     * @memberof IdentifierEntity
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof IdentifierEntity
     */
    'key': string;
    /**
     * 
     * @type {number}
     * @memberof IdentifierEntity
     */
    'projectId': number;
    /**
     * 
     * @type {number}
     * @memberof IdentifierEntity
     */
    'userId'?: number;
    /**
     * 
     * @type {number}
     * @memberof IdentifierEntity
     */
    'parentId'?: number;
    /**
     * 
     * @type {number}
     * @memberof IdentifierEntity
     */
    'branchId': number;
    /**
     * 
     * @type {boolean}
     * @memberof IdentifierEntity
     */
    'deleted': boolean;
    /**
     * 
     * @type {string}
     * @memberof IdentifierEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof IdentifierEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {Array<IdentifierEntity>}
     * @memberof IdentifierEntity
     */
    'children': Array<IdentifierEntity>;
    /**
     * 
     * @type {Array<TranslationEntity>}
     * @memberof IdentifierEntity
     */
    'translations': Array<TranslationEntity>;
}
/**
 * 
 * @export
 * @interface InvitationResponse
 */
export interface InvitationResponse {
    /**
     * 
     * @type {number}
     * @memberof InvitationResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof InvitationResponse
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof InvitationResponse
     */
    'token': string;
    /**
     * 
     * @type {SERVERROLE}
     * @memberof InvitationResponse
     */
    'role': SERVERROLE;
    /**
     * 
     * @type {string}
     * @memberof InvitationResponse
     */
    'expiration': string;
    /**
     * 
     * @type {number}
     * @memberof InvitationResponse
     */
    'initiatorId'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvitationResponse
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof InvitationResponse
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface Invite
 */
export interface Invite {
    /**
     * 
     * @type {number}
     * @memberof Invite
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Invite
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof Invite
     */
    'token': string;
    /**
     * 
     * @type {SERVERROLE}
     * @memberof Invite
     */
    'role': SERVERROLE;
    /**
     * 
     * @type {string}
     * @memberof Invite
     */
    'expiration': string;
    /**
     * 
     * @type {number}
     * @memberof Invite
     */
    'initiatorId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Invite
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Invite
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface Language
 */
export interface Language {
    /**
     * 
     * @type {number}
     * @memberof Language
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof Language
     */
    'deleted': boolean;
    /**
     * 
     * @type {number}
     * @memberof Language
     */
    'projectId': number;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface ListCommentDto
 */
export interface ListCommentDto {
    /**
     * 
     * @type {number}
     * @memberof ListCommentDto
     */
    'bundleId': number;
}
/**
 * 
 * @export
 * @interface ListReviewDto
 */
export interface ListReviewDto {
    /**
     * 
     * @type {number}
     * @memberof ListReviewDto
     */
    'translationId': number;
}
/**
 * 
 * @export
 * @interface LoginDto
 */
export interface LoginDto {
    /**
     * 
     * @type {string}
     * @memberof LoginDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginDto
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginDto
     */
    'tokenDescription'?: string;
}
/**
 * 
 * @export
 * @interface MergeBranchDto
 */
export interface MergeBranchDto {
    /**
     * Target branch to merge into
     * @type {number}
     * @memberof MergeBranchDto
     */
    'branchId': number;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'ownerId': number;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum REVIEWSTATUS {
    ChangeRequest = 'CHANGE_REQUEST',
    Approved = 'APPROVED',
    Denied = 'DENIED'
}

/**
 * 
 * @export
 * @interface RefreshTokenDto
 */
export interface RefreshTokenDto {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenDto
     */
    'refresh'?: string;
}
/**
 * 
 * @export
 * @interface RegisterDto
 */
export interface RegisterDto {
    /**
     * 
     * @type {string}
     * @memberof RegisterDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterDto
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterDto
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterDto
     */
    'tokenDescription'?: string;
}
/**
 * 
 * @export
 * @interface Response
 */
export interface Response {
    /**
     * 
     * @type {number}
     * @memberof Response
     */
    'statusCode': number;
    /**
     * 
     * @type {string}
     * @memberof Response
     */
    'message'?: string;
    /**
     * 
     * @type {object}
     * @memberof Response
     */
    'data'?: object;
}
/**
 * 
 * @export
 * @interface Review
 */
export interface Review {
    /**
     * 
     * @type {number}
     * @memberof Review
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'comment'?: string;
    /**
     * 
     * @type {number}
     * @memberof Review
     */
    'reviewerId'?: number;
    /**
     * 
     * @type {number}
     * @memberof Review
     */
    'translationId': number;
    /**
     * 
     * @type {REVIEWSTATUS}
     * @memberof Review
     */
    'status': REVIEWSTATUS;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface Right
 */
export interface Right {
    /**
     * 
     * @type {number}
     * @memberof Right
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Right
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Right
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Right
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Right
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {number}
     * @memberof Role
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum SERVERROLE {
    User = 'USER',
    Po = 'PO',
    Hr = 'HR',
    Admin = 'ADMIN'
}

/**
 * 
 * @export
 * @interface SocialDto
 */
export interface SocialDto {
    /**
     * 
     * @type {string}
     * @memberof SocialDto
     */
    'token': string;
    /**
     * 
     * @type {number}
     * @memberof SocialDto
     */
    'tokenDescription'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum TOKENTYPE {
    Bearer = 'BEARER',
    Access = 'ACCESS'
}

/**
 * 
 * @export
 * @interface TokenDto
 */
export interface TokenDto {
    /**
     * 
     * @type {string}
     * @memberof TokenDto
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenDto
     */
    'refresh': string;
    /**
     * 
     * @type {string}
     * @memberof TokenDto
     */
    'server': string;
}
/**
 * 
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * 
     * @type {number}
     * @memberof TokenResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'refresh'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'expiration': string;
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'name'?: string;
    /**
     * 
     * @type {TOKENTYPE}
     * @memberof TokenResponse
     */
    'type': TOKENTYPE;
    /**
     * 
     * @type {number}
     * @memberof TokenResponse
     */
    'userId': number;
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface TransferProjectDto
 */
export interface TransferProjectDto {
    /**
     * 
     * @type {number}
     * @memberof TransferProjectDto
     */
    'ownerId': number;
}
/**
 * 
 * @export
 * @interface Translation
 */
export interface Translation {
    /**
     * 
     * @type {number}
     * @memberof Translation
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Translation
     */
    'value': string;
    /**
     * 
     * @type {boolean}
     * @memberof Translation
     */
    'deleted': boolean;
    /**
     * 
     * @type {number}
     * @memberof Translation
     */
    'identifierId': number;
    /**
     * 
     * @type {number}
     * @memberof Translation
     */
    'languageId': number;
    /**
     * 
     * @type {number}
     * @memberof Translation
     */
    'userId'?: number;
    /**
     * 
     * @type {number}
     * @memberof Translation
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof Translation
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof Translation
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface TranslationEntity
 */
export interface TranslationEntity {
    /**
     * 
     * @type {number}
     * @memberof TranslationEntity
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TranslationEntity
     */
    'value': string;
    /**
     * 
     * @type {boolean}
     * @memberof TranslationEntity
     */
    'deleted': boolean;
    /**
     * 
     * @type {number}
     * @memberof TranslationEntity
     */
    'identifierId': number;
    /**
     * 
     * @type {number}
     * @memberof TranslationEntity
     */
    'languageId': number;
    /**
     * 
     * @type {number}
     * @memberof TranslationEntity
     */
    'userId'?: number;
    /**
     * 
     * @type {number}
     * @memberof TranslationEntity
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof TranslationEntity
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof TranslationEntity
     */
    'createdAt': string;
    /**
     * 
     * @type {Language}
     * @memberof TranslationEntity
     */
    'language': Language;
}
/**
 * 
 * @export
 * @interface UpdateBundleDto
 */
export interface UpdateBundleDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateBundleDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBundleDto
     */
    'description'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateBundleDto
     */
    'translations'?: Array<number>;
}
/**
 * 
 * @export
 * @interface UpdateIdentifierDto
 */
export interface UpdateIdentifierDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateIdentifierDto
     */
    'key'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateIdentifierDto
     */
    'branchId'?: number;
}
/**
 * 
 * @export
 * @interface UpdateLanguageDto
 */
export interface UpdateLanguageDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateLanguageDto
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateLanguageDto
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateLanguageDto
     */
    'deleted'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateMeDto
 */
export interface UpdateMeDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateMeDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMeDto
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMeDto
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMeDto
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface UpdateProjectDto
 */
export interface UpdateProjectDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface UpdateRoleDto
 */
export interface UpdateRoleDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateRoleDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoleDto
     */
    'description'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateRoleDto
     */
    'rights'?: Array<number>;
}
/**
 * 
 * @export
 * @interface UpdateTranslationDto
 */
export interface UpdateTranslationDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateTranslationDto
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface UpdateUserDto
 */
export interface UpdateUserDto {
    /**
     * 
     * @type {SERVERROLE}
     * @memberof UpdateUserDto
     */
    'role'?: SERVERROLE;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserDto
     */
    'disabled'?: boolean;
}
/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {number}
     * @memberof UserResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'googleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'password'?: string;
    /**
     * 
     * @type {SERVERROLE}
     * @memberof UserResponse
     */
    'role': SERVERROLE;
    /**
     * 
     * @type {boolean}
     * @memberof UserResponse
     */
    'disabled': boolean;
    /**
     * 
     * @type {number}
     * @memberof UserResponse
     */
    'inviteId': number;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'createdAt': string;
}

/**
 * AccessApi - axios parameter creator
 * @export
 */
export const AccessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateAccessDto} createAccessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessesCreate: async (createAccessDto: CreateAccessDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAccessDto' is not null or undefined
            assertParamExists('accessesCreate', 'createAccessDto', createAccessDto)
            const localVarPath = `/api/accesses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccessDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [projectId] 
         * @param {number} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessesFindAll: async (projectId?: number, userId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/accesses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessesFindOne: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accessesFindOne', 'id', id)
            const localVarPath = `/api/accesses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessesRegrant: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accessesRegrant', 'id', id)
            const localVarPath = `/api/accesses/{id}/regrant`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessesRemove: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accessesRemove', 'id', id)
            const localVarPath = `/api/accesses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessesRevoke: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accessesRevoke', 'id', id)
            const localVarPath = `/api/accesses/{id}/revoke`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessApi - functional programming interface
 * @export
 */
export const AccessApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateAccessDto} createAccessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessesCreate(createAccessDto: CreateAccessDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessesCreate(createAccessDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [projectId] 
         * @param {number} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessesFindAll(projectId?: number, userId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessesFindAll(projectId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessesFindOne(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessesFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessesRegrant(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessesRegrant(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessesRemove(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessesRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessesRevoke(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessesRevoke(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccessApi - factory interface
 * @export
 */
export const AccessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateAccessDto} createAccessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessesCreate(createAccessDto: CreateAccessDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.accessesCreate(createAccessDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [projectId] 
         * @param {number} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessesFindAll(projectId?: number, userId?: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.accessesFindAll(projectId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessesFindOne(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.accessesFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessesRegrant(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.accessesRegrant(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessesRemove(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.accessesRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessesRevoke(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.accessesRevoke(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccessApi - object-oriented interface
 * @export
 * @class AccessApi
 * @extends {BaseAPI}
 */
export class AccessApi extends BaseAPI {
    /**
     * 
     * @param {CreateAccessDto} createAccessDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public accessesCreate(createAccessDto: CreateAccessDto, options?: AxiosRequestConfig) {
        return AccessApiFp(this.configuration).accessesCreate(createAccessDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [projectId] 
     * @param {number} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public accessesFindAll(projectId?: number, userId?: number, options?: AxiosRequestConfig) {
        return AccessApiFp(this.configuration).accessesFindAll(projectId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public accessesFindOne(id: number, options?: AxiosRequestConfig) {
        return AccessApiFp(this.configuration).accessesFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public accessesRegrant(id: number, options?: AxiosRequestConfig) {
        return AccessApiFp(this.configuration).accessesRegrant(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public accessesRemove(id: number, options?: AxiosRequestConfig) {
        return AccessApiFp(this.configuration).accessesRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public accessesRevoke(id: number, options?: AxiosRequestConfig) {
        return AccessApiFp(this.configuration).accessesRevoke(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AppApi - axios parameter creator
 * @export
 */
export const AppApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appGetHello: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppApi - functional programming interface
 * @export
 */
export const AppApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appGetHello(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appGetHello(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AppApi - factory interface
 * @export
 */
export const AppApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appGetHello(options?: any): AxiosPromise<void> {
            return localVarFp.appGetHello(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppApi - object-oriented interface
 * @export
 * @class AppApi
 * @extends {BaseAPI}
 */
export class AppApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppApi
     */
    public appGetHello(options?: AxiosRequestConfig) {
        return AppApiFp(this.configuration).appGetHello(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ClaimTokenDto} claimTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authClaim: async (claimTokenDto: ClaimTokenDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'claimTokenDto' is not null or undefined
            assertParamExists('authClaim', 'claimTokenDto', claimTokenDto)
            const localVarPath = `/api/auth/claim`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(claimTokenDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SocialDto} socialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGoogleLogin: async (socialDto: SocialDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'socialDto' is not null or undefined
            assertParamExists('authGoogleLogin', 'socialDto', socialDto)
            const localVarPath = `/api/auth/google-signin/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(socialDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} token 
         * @param {SocialDto} socialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGoogleRegister: async (token: string, socialDto: SocialDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('authGoogleRegister', 'token', token)
            // verify required parameter 'socialDto' is not null or undefined
            assertParamExists('authGoogleRegister', 'socialDto', socialDto)
            const localVarPath = `/api/auth/google-signin/register/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(socialDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogin: async (loginDto: LoginDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginDto' is not null or undefined
            assertParamExists('authLogin', 'loginDto', loginDto)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} token 
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegister: async (token: string, registerDto: RegisterDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('authRegister', 'token', token)
            // verify required parameter 'registerDto' is not null or undefined
            assertParamExists('authRegister', 'registerDto', registerDto)
            const localVarPath = `/api/auth/register/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterProbe: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('authRegisterProbe', 'token', token)
            const localVarPath = `/api/auth/register/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ClaimTokenDto} claimTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authClaim(claimTokenDto: ClaimTokenDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authClaim(claimTokenDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SocialDto} socialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authGoogleLogin(socialDto: SocialDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authGoogleLogin(socialDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} token 
         * @param {SocialDto} socialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authGoogleRegister(token: string, socialDto: SocialDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authGoogleRegister(token, socialDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogin(loginDto: LoginDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogin(loginDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} token 
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRegister(token: string, registerDto: RegisterDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRegister(token, registerDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRegisterProbe(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRegisterProbe(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @param {ClaimTokenDto} claimTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authClaim(claimTokenDto: ClaimTokenDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.authClaim(claimTokenDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SocialDto} socialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGoogleLogin(socialDto: SocialDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.authGoogleLogin(socialDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} token 
         * @param {SocialDto} socialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGoogleRegister(token: string, socialDto: SocialDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.authGoogleRegister(token, socialDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogin(loginDto: LoginDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.authLogin(loginDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} token 
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegister(token: string, registerDto: RegisterDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.authRegister(token, registerDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterProbe(token: string, options?: any): AxiosPromise<Response & object> {
            return localVarFp.authRegisterProbe(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @param {ClaimTokenDto} claimTokenDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authClaim(claimTokenDto: ClaimTokenDto, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authClaim(claimTokenDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SocialDto} socialDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authGoogleLogin(socialDto: SocialDto, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authGoogleLogin(socialDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} token 
     * @param {SocialDto} socialDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authGoogleRegister(token: string, socialDto: SocialDto, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authGoogleRegister(token, socialDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authLogin(loginDto: LoginDto, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authLogin(loginDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} token 
     * @param {RegisterDto} registerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authRegister(token: string, registerDto: RegisterDto, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authRegister(token, registerDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authRegisterProbe(token: string, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authRegisterProbe(token, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BranchesApi - axios parameter creator
 * @export
 */
export const BranchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateBranchDto} createBranchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchesCreate: async (createBranchDto: CreateBranchDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBranchDto' is not null or undefined
            assertParamExists('branchesCreate', 'createBranchDto', createBranchDto)
            const localVarPath = `/api/branches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBranchDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchesFindAll: async (projectId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('branchesFindAll', 'projectId', projectId)
            const localVarPath = `/api/branches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchesFindOne: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('branchesFindOne', 'id', id)
            const localVarPath = `/api/branches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {MergeBranchDto} mergeBranchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchesMerge: async (id: number, mergeBranchDto: MergeBranchDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('branchesMerge', 'id', id)
            // verify required parameter 'mergeBranchDto' is not null or undefined
            assertParamExists('branchesMerge', 'mergeBranchDto', mergeBranchDto)
            const localVarPath = `/api/branches/{id}/merge`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mergeBranchDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchesRemove: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('branchesRemove', 'id', id)
            const localVarPath = `/api/branches/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BranchesApi - functional programming interface
 * @export
 */
export const BranchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BranchesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateBranchDto} createBranchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchesCreate(createBranchDto: CreateBranchDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchesCreate(createBranchDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchesFindAll(projectId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchesFindAll(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchesFindOne(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchesFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {MergeBranchDto} mergeBranchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchesMerge(id: number, mergeBranchDto: MergeBranchDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchesMerge(id, mergeBranchDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async branchesRemove(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.branchesRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BranchesApi - factory interface
 * @export
 */
export const BranchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BranchesApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateBranchDto} createBranchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchesCreate(createBranchDto: CreateBranchDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.branchesCreate(createBranchDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchesFindAll(projectId: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.branchesFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchesFindOne(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.branchesFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {MergeBranchDto} mergeBranchDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchesMerge(id: number, mergeBranchDto: MergeBranchDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.branchesMerge(id, mergeBranchDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        branchesRemove(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.branchesRemove(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BranchesApi - object-oriented interface
 * @export
 * @class BranchesApi
 * @extends {BaseAPI}
 */
export class BranchesApi extends BaseAPI {
    /**
     * 
     * @param {CreateBranchDto} createBranchDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchesCreate(createBranchDto: CreateBranchDto, options?: AxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchesCreate(createBranchDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchesFindAll(projectId: number, options?: AxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchesFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchesFindOne(id: number, options?: AxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchesFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {MergeBranchDto} mergeBranchDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchesMerge(id: number, mergeBranchDto: MergeBranchDto, options?: AxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchesMerge(id, mergeBranchDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public branchesRemove(id: number, options?: AxiosRequestConfig) {
        return BranchesApiFp(this.configuration).branchesRemove(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BundlesApi - axios parameter creator
 * @export
 */
export const BundlesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateBundleDto} createBundleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundlesCreate: async (createBundleDto: CreateBundleDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBundleDto' is not null or undefined
            assertParamExists('bundlesCreate', 'createBundleDto', createBundleDto)
            const localVarPath = `/api/bundles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBundleDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundlesFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/bundles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundlesFindOne: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bundlesFindOne', 'id', id)
            const localVarPath = `/api/bundles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundlesRemove: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bundlesRemove', 'id', id)
            const localVarPath = `/api/bundles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateBundleDto} updateBundleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundlesUpdate: async (id: number, updateBundleDto: UpdateBundleDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bundlesUpdate', 'id', id)
            // verify required parameter 'updateBundleDto' is not null or undefined
            assertParamExists('bundlesUpdate', 'updateBundleDto', updateBundleDto)
            const localVarPath = `/api/bundles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBundleDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BundlesApi - functional programming interface
 * @export
 */
export const BundlesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BundlesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateBundleDto} createBundleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bundlesCreate(createBundleDto: CreateBundleDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bundlesCreate(createBundleDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bundlesFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bundlesFindAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bundlesFindOne(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bundlesFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bundlesRemove(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bundlesRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateBundleDto} updateBundleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bundlesUpdate(id: number, updateBundleDto: UpdateBundleDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bundlesUpdate(id, updateBundleDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BundlesApi - factory interface
 * @export
 */
export const BundlesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BundlesApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateBundleDto} createBundleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundlesCreate(createBundleDto: CreateBundleDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.bundlesCreate(createBundleDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundlesFindAll(options?: any): AxiosPromise<Response & object> {
            return localVarFp.bundlesFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundlesFindOne(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.bundlesFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundlesRemove(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.bundlesRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateBundleDto} updateBundleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundlesUpdate(id: number, updateBundleDto: UpdateBundleDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.bundlesUpdate(id, updateBundleDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BundlesApi - object-oriented interface
 * @export
 * @class BundlesApi
 * @extends {BaseAPI}
 */
export class BundlesApi extends BaseAPI {
    /**
     * 
     * @param {CreateBundleDto} createBundleDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundlesApi
     */
    public bundlesCreate(createBundleDto: CreateBundleDto, options?: AxiosRequestConfig) {
        return BundlesApiFp(this.configuration).bundlesCreate(createBundleDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundlesApi
     */
    public bundlesFindAll(options?: AxiosRequestConfig) {
        return BundlesApiFp(this.configuration).bundlesFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundlesApi
     */
    public bundlesFindOne(id: number, options?: AxiosRequestConfig) {
        return BundlesApiFp(this.configuration).bundlesFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundlesApi
     */
    public bundlesRemove(id: number, options?: AxiosRequestConfig) {
        return BundlesApiFp(this.configuration).bundlesRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UpdateBundleDto} updateBundleDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundlesApi
     */
    public bundlesUpdate(id: number, updateBundleDto: UpdateBundleDto, options?: AxiosRequestConfig) {
        return BundlesApiFp(this.configuration).bundlesUpdate(id, updateBundleDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CommentsApi - axios parameter creator
 * @export
 */
export const CommentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateCommentDto} createCommentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsCreate: async (createCommentDto: CreateCommentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCommentDto' is not null or undefined
            assertParamExists('commentsCreate', 'createCommentDto', createCommentDto)
            const localVarPath = `/api/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCommentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ListCommentDto} listCommentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsFindAll: async (listCommentDto: ListCommentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listCommentDto' is not null or undefined
            assertParamExists('commentsFindAll', 'listCommentDto', listCommentDto)
            const localVarPath = `/api/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listCommentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsFindOne: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('commentsFindOne', 'id', id)
            const localVarPath = `/api/comments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsRemove: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('commentsRemove', 'id', id)
            const localVarPath = `/api/comments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsResolve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('commentsResolve', 'id', id)
            const localVarPath = `/api/comments/{id}/resolve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommentsApi - functional programming interface
 * @export
 */
export const CommentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateCommentDto} createCommentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentsCreate(createCommentDto: CreateCommentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentsCreate(createCommentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ListCommentDto} listCommentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentsFindAll(listCommentDto: ListCommentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentsFindAll(listCommentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentsFindOne(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentsFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentsRemove(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentsRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commentsResolve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commentsResolve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CommentsApi - factory interface
 * @export
 */
export const CommentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommentsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateCommentDto} createCommentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsCreate(createCommentDto: CreateCommentDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.commentsCreate(createCommentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ListCommentDto} listCommentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsFindAll(listCommentDto: ListCommentDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.commentsFindAll(listCommentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsFindOne(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.commentsFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsRemove(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.commentsRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commentsResolve(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.commentsResolve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommentsApi - object-oriented interface
 * @export
 * @class CommentsApi
 * @extends {BaseAPI}
 */
export class CommentsApi extends BaseAPI {
    /**
     * 
     * @param {CreateCommentDto} createCommentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public commentsCreate(createCommentDto: CreateCommentDto, options?: AxiosRequestConfig) {
        return CommentsApiFp(this.configuration).commentsCreate(createCommentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ListCommentDto} listCommentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public commentsFindAll(listCommentDto: ListCommentDto, options?: AxiosRequestConfig) {
        return CommentsApiFp(this.configuration).commentsFindAll(listCommentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public commentsFindOne(id: number, options?: AxiosRequestConfig) {
        return CommentsApiFp(this.configuration).commentsFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public commentsRemove(id: number, options?: AxiosRequestConfig) {
        return CommentsApiFp(this.configuration).commentsRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsApi
     */
    public commentsResolve(id: number, options?: AxiosRequestConfig) {
        return CommentsApiFp(this.configuration).commentsResolve(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdentifiersApi - axios parameter creator
 * @export
 */
export const IdentifiersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateIdentifierDto} createIdentifierDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifiersCreate: async (createIdentifierDto: CreateIdentifierDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createIdentifierDto' is not null or undefined
            assertParamExists('identifiersCreate', 'createIdentifierDto', createIdentifierDto)
            const localVarPath = `/api/identifiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createIdentifierDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [projectId] 
         * @param {number} [parentId] 
         * @param {number} [branches] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifiersFindAll: async (projectId?: number, parentId?: number, branches?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/identifiers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (branches !== undefined) {
                localVarQueryParameter['branches'] = branches;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifiersFindOne: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('identifiersFindOne', 'id', id)
            const localVarPath = `/api/identifiers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifiersRemove: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('identifiersRemove', 'id', id)
            const localVarPath = `/api/identifiers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} projectId 
         * @param {string} branches 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifiersTree: async (projectId: number, branches: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('identifiersTree', 'projectId', projectId)
            // verify required parameter 'branches' is not null or undefined
            assertParamExists('identifiersTree', 'branches', branches)
            const localVarPath = `/api/identifiers/tree`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (branches !== undefined) {
                localVarQueryParameter['branches'] = branches;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateIdentifierDto} updateIdentifierDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifiersUpdate: async (id: number, updateIdentifierDto: UpdateIdentifierDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('identifiersUpdate', 'id', id)
            // verify required parameter 'updateIdentifierDto' is not null or undefined
            assertParamExists('identifiersUpdate', 'updateIdentifierDto', updateIdentifierDto)
            const localVarPath = `/api/identifiers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateIdentifierDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdentifiersApi - functional programming interface
 * @export
 */
export const IdentifiersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdentifiersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateIdentifierDto} createIdentifierDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifiersCreate(createIdentifierDto: CreateIdentifierDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifiersCreate(createIdentifierDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [projectId] 
         * @param {number} [parentId] 
         * @param {number} [branches] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifiersFindAll(projectId?: number, parentId?: number, branches?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifiersFindAll(projectId, parentId, branches, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifiersFindOne(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifiersFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifiersRemove(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifiersRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} projectId 
         * @param {string} branches 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifiersTree(projectId: number, branches: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifiersTree(projectId, branches, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateIdentifierDto} updateIdentifierDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifiersUpdate(id: number, updateIdentifierDto: UpdateIdentifierDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifiersUpdate(id, updateIdentifierDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdentifiersApi - factory interface
 * @export
 */
export const IdentifiersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdentifiersApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateIdentifierDto} createIdentifierDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifiersCreate(createIdentifierDto: CreateIdentifierDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.identifiersCreate(createIdentifierDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [projectId] 
         * @param {number} [parentId] 
         * @param {number} [branches] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifiersFindAll(projectId?: number, parentId?: number, branches?: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.identifiersFindAll(projectId, parentId, branches, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifiersFindOne(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.identifiersFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifiersRemove(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.identifiersRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} projectId 
         * @param {string} branches 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifiersTree(projectId: number, branches: string, options?: any): AxiosPromise<Response & object> {
            return localVarFp.identifiersTree(projectId, branches, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateIdentifierDto} updateIdentifierDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifiersUpdate(id: number, updateIdentifierDto: UpdateIdentifierDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.identifiersUpdate(id, updateIdentifierDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdentifiersApi - object-oriented interface
 * @export
 * @class IdentifiersApi
 * @extends {BaseAPI}
 */
export class IdentifiersApi extends BaseAPI {
    /**
     * 
     * @param {CreateIdentifierDto} createIdentifierDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentifiersApi
     */
    public identifiersCreate(createIdentifierDto: CreateIdentifierDto, options?: AxiosRequestConfig) {
        return IdentifiersApiFp(this.configuration).identifiersCreate(createIdentifierDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [projectId] 
     * @param {number} [parentId] 
     * @param {number} [branches] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentifiersApi
     */
    public identifiersFindAll(projectId?: number, parentId?: number, branches?: number, options?: AxiosRequestConfig) {
        return IdentifiersApiFp(this.configuration).identifiersFindAll(projectId, parentId, branches, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentifiersApi
     */
    public identifiersFindOne(id: number, options?: AxiosRequestConfig) {
        return IdentifiersApiFp(this.configuration).identifiersFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentifiersApi
     */
    public identifiersRemove(id: number, options?: AxiosRequestConfig) {
        return IdentifiersApiFp(this.configuration).identifiersRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} projectId 
     * @param {string} branches 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentifiersApi
     */
    public identifiersTree(projectId: number, branches: string, options?: AxiosRequestConfig) {
        return IdentifiersApiFp(this.configuration).identifiersTree(projectId, branches, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UpdateIdentifierDto} updateIdentifierDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdentifiersApi
     */
    public identifiersUpdate(id: number, updateIdentifierDto: UpdateIdentifierDto, options?: AxiosRequestConfig) {
        return IdentifiersApiFp(this.configuration).identifiersUpdate(id, updateIdentifierDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InvitationsApi - axios parameter creator
 * @export
 */
export const InvitationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateInvitationDto} createInvitationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitationsCreate: async (createInvitationDto: CreateInvitationDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createInvitationDto' is not null or undefined
            assertParamExists('invitationsCreate', 'createInvitationDto', createInvitationDto)
            const localVarPath = `/api/invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createInvitationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitationsFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitationsFindOne: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('invitationsFindOne', 'id', id)
            const localVarPath = `/api/invitations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitationsRemove: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('invitationsRemove', 'id', id)
            const localVarPath = `/api/invitations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitationsResend: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('invitationsResend', 'id', id)
            const localVarPath = `/api/invitations/{id}/resend`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvitationsApi - functional programming interface
 * @export
 */
export const InvitationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvitationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateInvitationDto} createInvitationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invitationsCreate(createInvitationDto: CreateInvitationDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invitationsCreate(createInvitationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invitationsFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invitationsFindAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invitationsFindOne(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invitationsFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invitationsRemove(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invitationsRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invitationsResend(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invitationsResend(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InvitationsApi - factory interface
 * @export
 */
export const InvitationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvitationsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateInvitationDto} createInvitationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitationsCreate(createInvitationDto: CreateInvitationDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.invitationsCreate(createInvitationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitationsFindAll(options?: any): AxiosPromise<Response & object> {
            return localVarFp.invitationsFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitationsFindOne(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.invitationsFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitationsRemove(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.invitationsRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitationsResend(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.invitationsResend(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvitationsApi - object-oriented interface
 * @export
 * @class InvitationsApi
 * @extends {BaseAPI}
 */
export class InvitationsApi extends BaseAPI {
    /**
     * 
     * @param {CreateInvitationDto} createInvitationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationsApi
     */
    public invitationsCreate(createInvitationDto: CreateInvitationDto, options?: AxiosRequestConfig) {
        return InvitationsApiFp(this.configuration).invitationsCreate(createInvitationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationsApi
     */
    public invitationsFindAll(options?: AxiosRequestConfig) {
        return InvitationsApiFp(this.configuration).invitationsFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationsApi
     */
    public invitationsFindOne(id: number, options?: AxiosRequestConfig) {
        return InvitationsApiFp(this.configuration).invitationsFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationsApi
     */
    public invitationsRemove(id: number, options?: AxiosRequestConfig) {
        return InvitationsApiFp(this.configuration).invitationsRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationsApi
     */
    public invitationsResend(id: number, options?: AxiosRequestConfig) {
        return InvitationsApiFp(this.configuration).invitationsResend(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LanguagesApi - axios parameter creator
 * @export
 */
export const LanguagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateLanguageDto} createLanguageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languagesCreate: async (createLanguageDto: CreateLanguageDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createLanguageDto' is not null or undefined
            assertParamExists('languagesCreate', 'createLanguageDto', createLanguageDto)
            const localVarPath = `/api/languages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createLanguageDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languagesFindAll: async (projectId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('languagesFindAll', 'projectId', projectId)
            const localVarPath = `/api/languages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languagesFindOne: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('languagesFindOne', 'id', id)
            const localVarPath = `/api/languages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languagesRemove: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('languagesRemove', 'id', id)
            const localVarPath = `/api/languages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateLanguageDto} updateLanguageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languagesUpdate: async (id: number, updateLanguageDto: UpdateLanguageDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('languagesUpdate', 'id', id)
            // verify required parameter 'updateLanguageDto' is not null or undefined
            assertParamExists('languagesUpdate', 'updateLanguageDto', updateLanguageDto)
            const localVarPath = `/api/languages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLanguageDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LanguagesApi - functional programming interface
 * @export
 */
export const LanguagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LanguagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateLanguageDto} createLanguageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languagesCreate(createLanguageDto: CreateLanguageDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languagesCreate(createLanguageDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languagesFindAll(projectId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languagesFindAll(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languagesFindOne(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languagesFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languagesRemove(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languagesRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateLanguageDto} updateLanguageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async languagesUpdate(id: number, updateLanguageDto: UpdateLanguageDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.languagesUpdate(id, updateLanguageDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LanguagesApi - factory interface
 * @export
 */
export const LanguagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LanguagesApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateLanguageDto} createLanguageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languagesCreate(createLanguageDto: CreateLanguageDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.languagesCreate(createLanguageDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languagesFindAll(projectId: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.languagesFindAll(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languagesFindOne(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.languagesFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languagesRemove(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.languagesRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateLanguageDto} updateLanguageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        languagesUpdate(id: number, updateLanguageDto: UpdateLanguageDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.languagesUpdate(id, updateLanguageDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LanguagesApi - object-oriented interface
 * @export
 * @class LanguagesApi
 * @extends {BaseAPI}
 */
export class LanguagesApi extends BaseAPI {
    /**
     * 
     * @param {CreateLanguageDto} createLanguageDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguagesApi
     */
    public languagesCreate(createLanguageDto: CreateLanguageDto, options?: AxiosRequestConfig) {
        return LanguagesApiFp(this.configuration).languagesCreate(createLanguageDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguagesApi
     */
    public languagesFindAll(projectId: number, options?: AxiosRequestConfig) {
        return LanguagesApiFp(this.configuration).languagesFindAll(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguagesApi
     */
    public languagesFindOne(id: number, options?: AxiosRequestConfig) {
        return LanguagesApiFp(this.configuration).languagesFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguagesApi
     */
    public languagesRemove(id: number, options?: AxiosRequestConfig) {
        return LanguagesApiFp(this.configuration).languagesRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UpdateLanguageDto} updateLanguageDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguagesApi
     */
    public languagesUpdate(id: number, updateLanguageDto: UpdateLanguageDto, options?: AxiosRequestConfig) {
        return LanguagesApiFp(this.configuration).languagesUpdate(id, updateLanguageDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateProjectDto} createProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsCreate: async (createProjectDto: CreateProjectDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProjectDto' is not null or undefined
            assertParamExists('projectsCreate', 'createProjectDto', createProjectDto)
            const localVarPath = `/api/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProjectDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsFindOne: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsFindOne', 'id', id)
            const localVarPath = `/api/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsRemove: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsRemove', 'id', id)
            const localVarPath = `/api/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {TransferProjectDto} transferProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsTransfer: async (id: number, transferProjectDto: TransferProjectDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsTransfer', 'id', id)
            // verify required parameter 'transferProjectDto' is not null or undefined
            assertParamExists('projectsTransfer', 'transferProjectDto', transferProjectDto)
            const localVarPath = `/api/projects/{id}/transfer`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transferProjectDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateProjectDto} updateProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsUpdate: async (id: number, updateProjectDto: UpdateProjectDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectsUpdate', 'id', id)
            // verify required parameter 'updateProjectDto' is not null or undefined
            assertParamExists('projectsUpdate', 'updateProjectDto', updateProjectDto)
            const localVarPath = `/api/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProjectDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateProjectDto} createProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsCreate(createProjectDto: CreateProjectDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsCreate(createProjectDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsFindAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsFindOne(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsRemove(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {TransferProjectDto} transferProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsTransfer(id: number, transferProjectDto: TransferProjectDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsTransfer(id, transferProjectDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateProjectDto} updateProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsUpdate(id: number, updateProjectDto: UpdateProjectDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsUpdate(id, updateProjectDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateProjectDto} createProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsCreate(createProjectDto: CreateProjectDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.projectsCreate(createProjectDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsFindAll(options?: any): AxiosPromise<Response & object> {
            return localVarFp.projectsFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsFindOne(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.projectsFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsRemove(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.projectsRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {TransferProjectDto} transferProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsTransfer(id: number, transferProjectDto: TransferProjectDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.projectsTransfer(id, transferProjectDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateProjectDto} updateProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsUpdate(id: number, updateProjectDto: UpdateProjectDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.projectsUpdate(id, updateProjectDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @param {CreateProjectDto} createProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsCreate(createProjectDto: CreateProjectDto, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsCreate(createProjectDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsFindAll(options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsFindOne(id: number, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsRemove(id: number, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {TransferProjectDto} transferProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsTransfer(id: number, transferProjectDto: TransferProjectDto, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsTransfer(id, transferProjectDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UpdateProjectDto} updateProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsUpdate(id: number, updateProjectDto: UpdateProjectDto, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsUpdate(id, updateProjectDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReviewsApi - axios parameter creator
 * @export
 */
export const ReviewsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateReviewDto} createReviewDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsCreate: async (createReviewDto: CreateReviewDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createReviewDto' is not null or undefined
            assertParamExists('reviewsCreate', 'createReviewDto', createReviewDto)
            const localVarPath = `/api/reviews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createReviewDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ListReviewDto} listReviewDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsFindAll: async (listReviewDto: ListReviewDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listReviewDto' is not null or undefined
            assertParamExists('reviewsFindAll', 'listReviewDto', listReviewDto)
            const localVarPath = `/api/reviews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listReviewDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsFindOne: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reviewsFindOne', 'id', id)
            const localVarPath = `/api/reviews/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsRemove: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reviewsRemove', 'id', id)
            const localVarPath = `/api/reviews/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReviewsApi - functional programming interface
 * @export
 */
export const ReviewsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReviewsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateReviewDto} createReviewDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reviewsCreate(createReviewDto: CreateReviewDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reviewsCreate(createReviewDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ListReviewDto} listReviewDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reviewsFindAll(listReviewDto: ListReviewDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reviewsFindAll(listReviewDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reviewsFindOne(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reviewsFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reviewsRemove(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reviewsRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReviewsApi - factory interface
 * @export
 */
export const ReviewsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReviewsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateReviewDto} createReviewDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsCreate(createReviewDto: CreateReviewDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.reviewsCreate(createReviewDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ListReviewDto} listReviewDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsFindAll(listReviewDto: ListReviewDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.reviewsFindAll(listReviewDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsFindOne(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.reviewsFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewsRemove(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.reviewsRemove(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReviewsApi - object-oriented interface
 * @export
 * @class ReviewsApi
 * @extends {BaseAPI}
 */
export class ReviewsApi extends BaseAPI {
    /**
     * 
     * @param {CreateReviewDto} createReviewDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewsApi
     */
    public reviewsCreate(createReviewDto: CreateReviewDto, options?: AxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).reviewsCreate(createReviewDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ListReviewDto} listReviewDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewsApi
     */
    public reviewsFindAll(listReviewDto: ListReviewDto, options?: AxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).reviewsFindAll(listReviewDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewsApi
     */
    public reviewsFindOne(id: number, options?: AxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).reviewsFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewsApi
     */
    public reviewsRemove(id: number, options?: AxiosRequestConfig) {
        return ReviewsApiFp(this.configuration).reviewsRemove(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RightsApi - axios parameter creator
 * @export
 */
export const RightsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [roleId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rightsFindAll: async (roleId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/rights`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (roleId !== undefined) {
                localVarQueryParameter['roleId'] = roleId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rightsFindOne: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rightsFindOne', 'id', id)
            const localVarPath = `/api/rights/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RightsApi - functional programming interface
 * @export
 */
export const RightsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RightsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [roleId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rightsFindAll(roleId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rightsFindAll(roleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rightsFindOne(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rightsFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RightsApi - factory interface
 * @export
 */
export const RightsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RightsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [roleId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rightsFindAll(roleId?: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.rightsFindAll(roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rightsFindOne(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.rightsFindOne(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RightsApi - object-oriented interface
 * @export
 * @class RightsApi
 * @extends {BaseAPI}
 */
export class RightsApi extends BaseAPI {
    /**
     * 
     * @param {number} [roleId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RightsApi
     */
    public rightsFindAll(roleId?: number, options?: AxiosRequestConfig) {
        return RightsApiFp(this.configuration).rightsFindAll(roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RightsApi
     */
    public rightsFindOne(id: number, options?: AxiosRequestConfig) {
        return RightsApiFp(this.configuration).rightsFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateRoleDto} createRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesCreate: async (createRoleDto: CreateRoleDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRoleDto' is not null or undefined
            assertParamExists('rolesCreate', 'createRoleDto', createRoleDto)
            const localVarPath = `/api/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoleDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesFindOne: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rolesFindOne', 'id', id)
            const localVarPath = `/api/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesRemove: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rolesRemove', 'id', id)
            const localVarPath = `/api/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateRoleDto} updateRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesUpdate: async (id: number, updateRoleDto: UpdateRoleDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rolesUpdate', 'id', id)
            // verify required parameter 'updateRoleDto' is not null or undefined
            assertParamExists('rolesUpdate', 'updateRoleDto', updateRoleDto)
            const localVarPath = `/api/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoleDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateRoleDto} createRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesCreate(createRoleDto: CreateRoleDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesCreate(createRoleDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesFindAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesFindOne(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesRemove(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateRoleDto} updateRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesUpdate(id: number, updateRoleDto: UpdateRoleDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesUpdate(id, updateRoleDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateRoleDto} createRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesCreate(createRoleDto: CreateRoleDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.rolesCreate(createRoleDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesFindAll(options?: any): AxiosPromise<Response & object> {
            return localVarFp.rolesFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesFindOne(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.rolesFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesRemove(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.rolesRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateRoleDto} updateRoleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesUpdate(id: number, updateRoleDto: UpdateRoleDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.rolesUpdate(id, updateRoleDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * 
     * @param {CreateRoleDto} createRoleDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesCreate(createRoleDto: CreateRoleDto, options?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesCreate(createRoleDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesFindAll(options?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesFindOne(id: number, options?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesRemove(id: number, options?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UpdateRoleDto} updateRoleDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesUpdate(id: number, updateRoleDto: UpdateRoleDto, options?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesUpdate(id, updateRoleDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TokensApi - axios parameter creator
 * @export
 */
export const TokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateTokenDto} createTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensCreate: async (createTokenDto: CreateTokenDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTokenDto' is not null or undefined
            assertParamExists('tokensCreate', 'createTokenDto', createTokenDto)
            const localVarPath = `/api/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTokenDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensFindOne: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tokensFindOne', 'id', id)
            const localVarPath = `/api/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensRefresh: async (refreshTokenDto: RefreshTokenDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenDto' is not null or undefined
            assertParamExists('tokensRefresh', 'refreshTokenDto', refreshTokenDto)
            const localVarPath = `/api/tokens/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensRemove: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tokensRemove', 'id', id)
            const localVarPath = `/api/tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokensApi - functional programming interface
 * @export
 */
export const TokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokensApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateTokenDto} createTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensCreate(createTokenDto: CreateTokenDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensCreate(createTokenDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensFindAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensFindOne(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensRefresh(refreshTokenDto: RefreshTokenDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensRefresh(refreshTokenDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokensRemove(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokensRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TokensApi - factory interface
 * @export
 */
export const TokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokensApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateTokenDto} createTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensCreate(createTokenDto: CreateTokenDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.tokensCreate(createTokenDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensFindAll(options?: any): AxiosPromise<Response & object> {
            return localVarFp.tokensFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensFindOne(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.tokensFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensRefresh(refreshTokenDto: RefreshTokenDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.tokensRefresh(refreshTokenDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensRemove(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.tokensRemove(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
export class TokensApi extends BaseAPI {
    /**
     * 
     * @param {CreateTokenDto} createTokenDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public tokensCreate(createTokenDto: CreateTokenDto, options?: AxiosRequestConfig) {
        return TokensApiFp(this.configuration).tokensCreate(createTokenDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public tokensFindAll(options?: AxiosRequestConfig) {
        return TokensApiFp(this.configuration).tokensFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public tokensFindOne(id: number, options?: AxiosRequestConfig) {
        return TokensApiFp(this.configuration).tokensFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RefreshTokenDto} refreshTokenDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public tokensRefresh(refreshTokenDto: RefreshTokenDto, options?: AxiosRequestConfig) {
        return TokensApiFp(this.configuration).tokensRefresh(refreshTokenDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public tokensRemove(id: number, options?: AxiosRequestConfig) {
        return TokensApiFp(this.configuration).tokensRemove(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TranslationsApi - axios parameter creator
 * @export
 */
export const TranslationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateTranslationDto} createTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsCreate: async (createTranslationDto: CreateTranslationDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTranslationDto' is not null or undefined
            assertParamExists('translationsCreate', 'createTranslationDto', createTranslationDto)
            const localVarPath = `/api/translations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTranslationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [deleted] 
         * @param {number} [identifierId] 
         * @param {number} [languageId] 
         * @param {number} [userId] 
         * @param {number} [allVersions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsFindAll: async (deleted?: boolean, identifierId?: number, languageId?: number, userId?: number, allVersions?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/translations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }

            if (identifierId !== undefined) {
                localVarQueryParameter['identifierId'] = identifierId;
            }

            if (languageId !== undefined) {
                localVarQueryParameter['languageId'] = languageId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (allVersions !== undefined) {
                localVarQueryParameter['allVersions'] = allVersions;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsFindOne: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('translationsFindOne', 'id', id)
            const localVarPath = `/api/translations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsRemove: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('translationsRemove', 'id', id)
            const localVarPath = `/api/translations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} projectId 
         * @param {string} branches 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsTree: async (projectId: number, branches: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('translationsTree', 'projectId', projectId)
            // verify required parameter 'branches' is not null or undefined
            assertParamExists('translationsTree', 'branches', branches)
            const localVarPath = `/api/translations/tree`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (branches !== undefined) {
                localVarQueryParameter['branches'] = branches;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateTranslationDto} updateTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsUpdate: async (id: number, updateTranslationDto: UpdateTranslationDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('translationsUpdate', 'id', id)
            // verify required parameter 'updateTranslationDto' is not null or undefined
            assertParamExists('translationsUpdate', 'updateTranslationDto', updateTranslationDto)
            const localVarPath = `/api/translations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTranslationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TranslationsApi - functional programming interface
 * @export
 */
export const TranslationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TranslationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateTranslationDto} createTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translationsCreate(createTranslationDto: CreateTranslationDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translationsCreate(createTranslationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} [deleted] 
         * @param {number} [identifierId] 
         * @param {number} [languageId] 
         * @param {number} [userId] 
         * @param {number} [allVersions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translationsFindAll(deleted?: boolean, identifierId?: number, languageId?: number, userId?: number, allVersions?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translationsFindAll(deleted, identifierId, languageId, userId, allVersions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translationsFindOne(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translationsFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translationsRemove(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translationsRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} projectId 
         * @param {string} branches 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translationsTree(projectId: number, branches: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translationsTree(projectId, branches, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateTranslationDto} updateTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translationsUpdate(id: number, updateTranslationDto: UpdateTranslationDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translationsUpdate(id, updateTranslationDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TranslationsApi - factory interface
 * @export
 */
export const TranslationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TranslationsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateTranslationDto} createTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsCreate(createTranslationDto: CreateTranslationDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.translationsCreate(createTranslationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [deleted] 
         * @param {number} [identifierId] 
         * @param {number} [languageId] 
         * @param {number} [userId] 
         * @param {number} [allVersions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsFindAll(deleted?: boolean, identifierId?: number, languageId?: number, userId?: number, allVersions?: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.translationsFindAll(deleted, identifierId, languageId, userId, allVersions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsFindOne(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.translationsFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsRemove(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.translationsRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} projectId 
         * @param {string} branches 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsTree(projectId: number, branches: string, options?: any): AxiosPromise<Response & object> {
            return localVarFp.translationsTree(projectId, branches, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateTranslationDto} updateTranslationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsUpdate(id: number, updateTranslationDto: UpdateTranslationDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.translationsUpdate(id, updateTranslationDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TranslationsApi - object-oriented interface
 * @export
 * @class TranslationsApi
 * @extends {BaseAPI}
 */
export class TranslationsApi extends BaseAPI {
    /**
     * 
     * @param {CreateTranslationDto} createTranslationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TranslationsApi
     */
    public translationsCreate(createTranslationDto: CreateTranslationDto, options?: AxiosRequestConfig) {
        return TranslationsApiFp(this.configuration).translationsCreate(createTranslationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [deleted] 
     * @param {number} [identifierId] 
     * @param {number} [languageId] 
     * @param {number} [userId] 
     * @param {number} [allVersions] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TranslationsApi
     */
    public translationsFindAll(deleted?: boolean, identifierId?: number, languageId?: number, userId?: number, allVersions?: number, options?: AxiosRequestConfig) {
        return TranslationsApiFp(this.configuration).translationsFindAll(deleted, identifierId, languageId, userId, allVersions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TranslationsApi
     */
    public translationsFindOne(id: number, options?: AxiosRequestConfig) {
        return TranslationsApiFp(this.configuration).translationsFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TranslationsApi
     */
    public translationsRemove(id: number, options?: AxiosRequestConfig) {
        return TranslationsApiFp(this.configuration).translationsRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} projectId 
     * @param {string} branches 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TranslationsApi
     */
    public translationsTree(projectId: number, branches: string, options?: AxiosRequestConfig) {
        return TranslationsApiFp(this.configuration).translationsTree(projectId, branches, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UpdateTranslationDto} updateTranslationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TranslationsApi
     */
    public translationsUpdate(id: number, updateTranslationDto: UpdateTranslationDto, options?: AxiosRequestConfig) {
        return TranslationsApiFp(this.configuration).translationsUpdate(id, updateTranslationDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SocialDto} socialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersConnectGoogle: async (socialDto: SocialDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'socialDto' is not null or undefined
            assertParamExists('usersConnectGoogle', 'socialDto', socialDto)
            const localVarPath = `/api/users/me/connect-google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(socialDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeleteUserDto} deleteUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeleteMe: async (deleteUserDto: DeleteUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteUserDto' is not null or undefined
            assertParamExists('usersDeleteMe', 'deleteUserDto', deleteUserDto)
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersFindOne: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersFindOne', 'id', id)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetMe: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersLogout: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersLogout', 'id', id)
            const localVarPath = `/api/users/{id}/logout`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRemove: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersRemove', 'id', id)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersReset: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersReset', 'id', id)
            const localVarPath = `/api/users/{id}/reset-password`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate: async (id: number, updateUserDto: UpdateUserDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersUpdate', 'id', id)
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('usersUpdate', 'updateUserDto', updateUserDto)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateMeDto} updateMeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdateMe: async (updateMeDto: UpdateMeDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateMeDto' is not null or undefined
            assertParamExists('usersUpdateMe', 'updateMeDto', updateMeDto)
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMeDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {SocialDto} socialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersConnectGoogle(socialDto: SocialDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersConnectGoogle(socialDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {DeleteUserDto} deleteUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersDeleteMe(deleteUserDto: DeleteUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersDeleteMe(deleteUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersFindAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersFindOne(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGetMe(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGetMe(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersLogout(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersLogout(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersRemove(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersReset(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersReset(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUpdate(id: number, updateUserDto: UpdateUserDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUpdate(id, updateUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateMeDto} updateMeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUpdateMe(updateMeDto: UpdateMeDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response & object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUpdateMe(updateMeDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @param {SocialDto} socialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersConnectGoogle(socialDto: SocialDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.usersConnectGoogle(socialDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeleteUserDto} deleteUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeleteMe(deleteUserDto: DeleteUserDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.usersDeleteMe(deleteUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersFindAll(options?: any): AxiosPromise<Response & object> {
            return localVarFp.usersFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersFindOne(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.usersFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetMe(options?: any): AxiosPromise<Response & object> {
            return localVarFp.usersGetMe(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersLogout(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.usersLogout(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRemove(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.usersRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersReset(id: number, options?: any): AxiosPromise<Response & object> {
            return localVarFp.usersReset(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate(id: number, updateUserDto: UpdateUserDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.usersUpdate(id, updateUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateMeDto} updateMeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdateMe(updateMeDto: UpdateMeDto, options?: any): AxiosPromise<Response & object> {
            return localVarFp.usersUpdateMe(updateMeDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {SocialDto} socialDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersConnectGoogle(socialDto: SocialDto, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersConnectGoogle(socialDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeleteUserDto} deleteUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersDeleteMe(deleteUserDto: DeleteUserDto, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersDeleteMe(deleteUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersFindAll(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersFindOne(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGetMe(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersGetMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersLogout(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersLogout(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersRemove(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersReset(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersReset(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UpdateUserDto} updateUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUpdate(id: number, updateUserDto: UpdateUserDto, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUpdate(id, updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateMeDto} updateMeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUpdateMe(updateMeDto: UpdateMeDto, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUpdateMe(updateMeDto, options).then((request) => request(this.axios, this.basePath));
    }
}



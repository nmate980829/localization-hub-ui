/* tslint:disable */
/* eslint-disable */
/**
 * REST API for the localization hub project
 * The project intends to provide a way to synchronize localization files, and streamline translation processes
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: nmate980829@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Access
 */
export interface Access {
    /**
     * 
     * @type {number}
     * @memberof Access
     */
    'id'?: number;
    /**
     * 
     * @type {Project}
     * @memberof Access
     */
    'project'?: Project;
    /**
     * 
     * @type {number}
     * @memberof Access
     */
    'projectId'?: number;
    /**
     * 
     * @type {User}
     * @memberof Access
     */
    'user'?: User;
    /**
     * 
     * @type {number}
     * @memberof Access
     */
    'userId'?: number;
    /**
     * 
     * @type {Role}
     * @memberof Access
     */
    'role'?: Role;
    /**
     * 
     * @type {number}
     * @memberof Access
     */
    'roleId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Access
     */
    'revoked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Access
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Access
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface AdminUpdateUserModel
 */
export interface AdminUpdateUserModel {
    /**
     * The new role of the user. Must be a SERVER_ROLE.
     * @type {string}
     * @memberof AdminUpdateUserModel
     */
    'role'?: string;
    /**
     * To set the user\'s account disabled or restore it.
     * @type {boolean}
     * @memberof AdminUpdateUserModel
     */
    'disabled'?: boolean;
}
/**
 * 
 * @export
 * @interface Bundle
 */
export interface Bundle {
    /**
     * 
     * @type {number}
     * @memberof Bundle
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'description'?: string;
    /**
     * 
     * @type {User}
     * @memberof Bundle
     */
    'issuer'?: User;
    /**
     * 
     * @type {number}
     * @memberof Bundle
     */
    'issuerId'?: number;
    /**
     * 
     * @type {User}
     * @memberof Bundle
     */
    'reviewer'?: User;
    /**
     * 
     * @type {number}
     * @memberof Bundle
     */
    'reviewerId'?: number | null;
    /**
     * 
     * @type {Array<Translation>}
     * @memberof Bundle
     */
    'translations'?: Array<Translation>;
    /**
     * 
     * @type {Array<Comment>}
     * @memberof Bundle
     */
    'comments'?: Array<Comment>;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'status'?: BundleStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Bundle
     */
    'createdAt'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum BundleStatusEnum {
    Draft = 'DRAFT',
    Submitted = 'SUBMITTED',
    ChangeRequest = 'CHANGE_REQUEST',
    Approved = 'APPROVED',
    Denied = 'DENIED'
}

/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'text'?: string | null;
    /**
     * 
     * @type {User}
     * @memberof Comment
     */
    'author'?: User;
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    'userId'?: number;
    /**
     * 
     * @type {Bundle}
     * @memberof Comment
     */
    'bundle'?: Bundle;
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    'bundleId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'status'?: CommentStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'createdAt'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum CommentStatusEnum {
    Draft = 'DRAFT',
    Submitted = 'SUBMITTED',
    ChangeRequest = 'CHANGE_REQUEST',
    Approved = 'APPROVED',
    Denied = 'DENIED'
}

/**
 * 
 * @export
 * @interface Config
 */
export interface Config {
    /**
     * 
     * @type {number}
     * @memberof Config
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Config
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof Config
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Config
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof Config
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Config
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface CreateAccessModel
 */
export interface CreateAccessModel {
    /**
     * The id of the project the access is given for
     * @type {number}
     * @memberof CreateAccessModel
     */
    'projectId': number;
    /**
     * The id of the user the access is given to
     * @type {number}
     * @memberof CreateAccessModel
     */
    'userId': number;
    /**
     * The role which should be given to the grantee. One of the the available project roles on the server.
     * @type {number}
     * @memberof CreateAccessModel
     */
    'roleId': number;
}
/**
 * 
 * @export
 * @interface CreateBundleModel
 */
export interface CreateBundleModel {
    /**
     * Name that identifies the bundle.
     * @type {string}
     * @memberof CreateBundleModel
     */
    'name': string;
    /**
     * Description to, explain the bundles purpose.
     * @type {string}
     * @memberof CreateBundleModel
     */
    'description': string;
    /**
     * The id of the project the bundle is created on
     * @type {number}
     * @memberof CreateBundleModel
     */
    'projectId': number;
    /**
     * The id-s of the translations that the bundle contains.
     * @type {Array<number>}
     * @memberof CreateBundleModel
     */
    'translations': Array<number>;
}
/**
 * 
 * @export
 * @interface CreateCommentModel
 */
export interface CreateCommentModel {
    /**
     * Text of the comment
     * @type {string}
     * @memberof CreateCommentModel
     */
    'text'?: string;
    /**
     * The bundle which the comment corresponds to.
     * @type {number}
     * @memberof CreateCommentModel
     */
    'bundleId': number;
    /**
     * The new status of the bundle. One of DRAFT, SUBMITTED, CHANGE_REQUEST, APPROVED, DENIED
     * @type {string}
     * @memberof CreateCommentModel
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface CreateConfigModel
 */
export interface CreateConfigModel {
    /**
     * The key identifying the configuration component.
     * @type {string}
     * @memberof CreateConfigModel
     */
    'key': string;
    /**
     * Human readable name of the component.
     * @type {string}
     * @memberof CreateConfigModel
     */
    'name': string;
    /**
     * The value of the config component
     * @type {string}
     * @memberof CreateConfigModel
     */
    'value': string;
    /**
     * The project which the configuration component corresponds to
     * @type {number}
     * @memberof CreateConfigModel
     */
    'projectId': number;
}
/**
 * 
 * @export
 * @interface CreateInviteModel
 */
export interface CreateInviteModel {
    /**
     * The email to create the invite to.
     * @type {string}
     * @memberof CreateInviteModel
     */
    'email': string;
    /**
     * The role which should be given to the invitee. One of the following USER is the default, PO, HR, ADMIN. Only admin can create admin invite, and hr any of the others.
     * @type {string}
     * @memberof CreateInviteModel
     */
    'role': string;
}
/**
 * 
 * @export
 * @interface CreateKeyModel
 */
export interface CreateKeyModel {
    /**
     * Identifies the translations in the context of the project and the parent key
     * @type {string}
     * @memberof CreateKeyModel
     */
    'key': string;
    /**
     * The project containing the key
     * @type {number}
     * @memberof CreateKeyModel
     */
    'projectId': number;
    /**
     * The hierarchical parent of the key in the tree of the project.
     * @type {number}
     * @memberof CreateKeyModel
     */
    'parentId'?: number;
}
/**
 * 
 * @export
 * @interface CreateLanguageModel
 */
export interface CreateLanguageModel {
    /**
     * The unique identifier of the language in the context of the project.
     * @type {string}
     * @memberof CreateLanguageModel
     */
    'key': string;
    /**
     * Long name of the language or any other description, deemed necessary by the managers of the project.
     * @type {string}
     * @memberof CreateLanguageModel
     */
    'description'?: string;
    /**
     * The owner project
     * @type {number}
     * @memberof CreateLanguageModel
     */
    'projectId': number;
}
/**
 * 
 * @export
 * @interface CreateProjectModel
 */
export interface CreateProjectModel {
    /**
     * The name to identify your project, in the context of the localization server
     * @type {string}
     * @memberof CreateProjectModel
     */
    'name': string;
    /**
     * Short description of the project
     * @type {string}
     * @memberof CreateProjectModel
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface CreateReviewModel
 */
export interface CreateReviewModel {
    /**
     * Your review comment of the translation.
     * @type {string}
     * @memberof CreateReviewModel
     */
    'comment'?: string;
    /**
     * The status of the translation after this review is submitted.
     * @type {string}
     * @memberof CreateReviewModel
     */
    'status'?: string;
    /**
     * The translation the review is for.
     * @type {number}
     * @memberof CreateReviewModel
     */
    'translationId'?: number;
}
/**
 * 
 * @export
 * @interface CreateRoleModel
 */
export interface CreateRoleModel {
    /**
     * The name to identify the role by.
     * @type {string}
     * @memberof CreateRoleModel
     */
    'name'?: string;
    /**
     * The description of the nature of the role
     * @type {string}
     * @memberof CreateRoleModel
     */
    'description'?: string;
    /**
     * The role to make a copy of. If suplied, the rights property cannot be present.
     * @type {string}
     * @memberof CreateRoleModel
     */
    'roleId'?: string;
    /**
     * The identifier of the rights the role should have
     * @type {Array<number>}
     * @memberof CreateRoleModel
     */
    'rights'?: Array<number>;
}
/**
 * 
 * @export
 * @interface CreateTranslationModel
 */
export interface CreateTranslationModel {
    /**
     * The value of the translation
     * @type {string}
     * @memberof CreateTranslationModel
     */
    'value': string;
    /**
     * Corresponding key.
     * @type {number}
     * @memberof CreateTranslationModel
     */
    'keyId': number;
    /**
     * Corresponding language
     * @type {number}
     * @memberof CreateTranslationModel
     */
    'languageId': number;
}
/**
 * 
 * @export
 * @interface IdModel
 */
export interface IdModel {
    /**
     * The identifier of the unique object
     * @type {number}
     * @memberof IdModel
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Array<Invite>}
     * @memberof InlineResponse200
     */
    'result': Array<Invite>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {Invite}
     * @memberof InlineResponse2001
     */
    'result': Invite;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {UserResponse}
     * @memberof InlineResponse2002
     */
    'result': UserResponse;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {Array<UserResponse>}
     * @memberof InlineResponse2003
     */
    'result': Array<UserResponse>;
}
/**
 * 
 * @export
 * @interface Invite
 */
export interface Invite {
    /**
     * 
     * @type {number}
     * @memberof Invite
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Invite
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invite
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invite
     */
    'role'?: InviteRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof Invite
     */
    'expiration'?: string;
    /**
     * 
     * @type {User}
     * @memberof Invite
     */
    'user'?: User;
    /**
     * 
     * @type {User}
     * @memberof Invite
     */
    'initiator'?: User;
    /**
     * 
     * @type {number}
     * @memberof Invite
     */
    'initiatorId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Invite
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Invite
     */
    'createdAt'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InviteRoleEnum {
    User = 'USER',
    Po = 'PO',
    Hr = 'HR',
    Admin = 'ADMIN'
}

/**
 * 
 * @export
 * @interface Key
 */
export interface Key {
    /**
     * 
     * @type {number}
     * @memberof Key
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Key
     */
    'key'?: string;
    /**
     * 
     * @type {Project}
     * @memberof Key
     */
    'project'?: Project;
    /**
     * 
     * @type {number}
     * @memberof Key
     */
    'projectId'?: number;
    /**
     * 
     * @type {User}
     * @memberof Key
     */
    'author'?: User;
    /**
     * 
     * @type {number}
     * @memberof Key
     */
    'userId'?: number;
    /**
     * 
     * @type {Key}
     * @memberof Key
     */
    'parent'?: Key;
    /**
     * 
     * @type {number}
     * @memberof Key
     */
    'parentId'?: number;
    /**
     * 
     * @type {Array<Key>}
     * @memberof Key
     */
    'children'?: Array<Key>;
    /**
     * 
     * @type {Array<Translation>}
     * @memberof Key
     */
    'translations'?: Array<Translation>;
    /**
     * 
     * @type {boolean}
     * @memberof Key
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Key
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Key
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface Language
 */
export interface Language {
    /**
     * 
     * @type {number}
     * @memberof Language
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Language
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {Project}
     * @memberof Language
     */
    'project'?: Project;
    /**
     * 
     * @type {number}
     * @memberof Language
     */
    'projectId'?: number;
    /**
     * 
     * @type {Array<Translation>}
     * @memberof Language
     */
    'translations'?: Array<Translation>;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface LoginRequestModel
 */
export interface LoginRequestModel {
    /**
     * Your email to identify your account.
     * @type {string}
     * @memberof LoginRequestModel
     */
    'email': string;
    /**
     * Your password
     * @type {string}
     * @memberof LoginRequestModel
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * The description of the nature of the error
     * @type {string}
     * @memberof ModelError
     */
    'error': string;
    /**
     * Additional data about the error
     * @type {string}
     * @memberof ModelError
     */
    'message'?: string;
    /**
     * An array of the missing inputs, formated as two string arrays.
     * @type {Array<Array<string>>}
     * @memberof ModelError
     */
    'missing'?: Array<Array<string>>;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'description'?: string;
    /**
     * 
     * @type {Array<Access>}
     * @memberof Project
     */
    'access'?: Array<Access>;
    /**
     * 
     * @type {Array<Key>}
     * @memberof Project
     */
    'keys'?: Array<Key>;
    /**
     * 
     * @type {Array<Language>}
     * @memberof Project
     */
    'languages'?: Array<Language>;
    /**
     * 
     * @type {User}
     * @memberof Project
     */
    'owner'?: User;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    'ownerId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface RegisterRequestModel
 */
export interface RegisterRequestModel {
    /**
     * Your email to identify your account.
     * @type {string}
     * @memberof RegisterRequestModel
     */
    'email': string;
    /**
     * Your password
     * @type {string}
     * @memberof RegisterRequestModel
     */
    'password': string;
    /**
     * Your first name
     * @type {string}
     * @memberof RegisterRequestModel
     */
    'firstName': string;
    /**
     * Your last name
     * @type {string}
     * @memberof RegisterRequestModel
     */
    'lastName': string;
}
/**
 * 
 * @export
 * @interface Review
 */
export interface Review {
    /**
     * 
     * @type {number}
     * @memberof Review
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'comment'?: string | null;
    /**
     * 
     * @type {User}
     * @memberof Review
     */
    'reviewer'?: User;
    /**
     * 
     * @type {number}
     * @memberof Review
     */
    'reviewerId'?: number;
    /**
     * 
     * @type {Translation}
     * @memberof Review
     */
    'translation'?: Translation;
    /**
     * 
     * @type {number}
     * @memberof Review
     */
    'translationId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'status'?: ReviewStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Review
     */
    'createdAt'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ReviewStatusEnum {
    ChangeRequest = 'CHANGE_REQUEST',
    Approved = 'APPROVED',
    Denied = 'DENIED'
}

/**
 * 
 * @export
 * @interface Right
 */
export interface Right {
    /**
     * 
     * @type {number}
     * @memberof Right
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Right
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Right
     */
    'description'?: string;
    /**
     * 
     * @type {Array<Role>}
     * @memberof Right
     */
    'roles'?: Array<Role>;
    /**
     * 
     * @type {string}
     * @memberof Right
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Right
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {number}
     * @memberof Role
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'description'?: string;
    /**
     * 
     * @type {Array<Access>}
     * @memberof Role
     */
    'accesses'?: Array<Access>;
    /**
     * 
     * @type {Array<Right>}
     * @memberof Role
     */
    'rights'?: Array<Right>;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface TokenModel
 */
export interface TokenModel {
    /**
     * Your token for registering provided in the invite
     * @type {string}
     * @memberof TokenModel
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface Translation
 */
export interface Translation {
    /**
     * 
     * @type {number}
     * @memberof Translation
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Translation
     */
    'value'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Translation
     */
    'deleted'?: boolean;
    /**
     * 
     * @type {Key}
     * @memberof Translation
     */
    'key'?: Key;
    /**
     * 
     * @type {number}
     * @memberof Translation
     */
    'keyId'?: number;
    /**
     * 
     * @type {Language}
     * @memberof Translation
     */
    'language'?: Language;
    /**
     * 
     * @type {number}
     * @memberof Translation
     */
    'languageId'?: number;
    /**
     * 
     * @type {User}
     * @memberof Translation
     */
    'author'?: User;
    /**
     * 
     * @type {number}
     * @memberof Translation
     */
    'userId'?: number;
    /**
     * 
     * @type {Array<Review>}
     * @memberof Translation
     */
    'reviews'?: Array<Review>;
    /**
     * 
     * @type {Array<Bundle>}
     * @memberof Translation
     */
    'bundles'?: Array<Bundle>;
    /**
     * 
     * @type {number}
     * @memberof Translation
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof Translation
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Translation
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface UpdateAccessModel
 */
export interface UpdateAccessModel {
    /**
     * The role which should be given to the grantee. One of the the available project roles on the server.
     * @type {number}
     * @memberof UpdateAccessModel
     */
    'roleId': number;
}
/**
 * 
 * @export
 * @interface UpdateBundleModel
 */
export interface UpdateBundleModel {
    /**
     * Name that identifies the bundle.
     * @type {string}
     * @memberof UpdateBundleModel
     */
    'name': string;
    /**
     * Description to, explain the bundles purpose.
     * @type {string}
     * @memberof UpdateBundleModel
     */
    'description': string;
    /**
     * The new status of the bundle. One of DRAFT, SUBMITTED, CHANGE_REQUEST, APPROVED, DENIED
     * @type {string}
     * @memberof UpdateBundleModel
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface UpdateConfigModel
 */
export interface UpdateConfigModel {
    /**
     * Human readable name of the component.
     * @type {string}
     * @memberof UpdateConfigModel
     */
    'name'?: string;
    /**
     * The value of the config component
     * @type {string}
     * @memberof UpdateConfigModel
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface UpdateLanguageModel
 */
export interface UpdateLanguageModel {
    /**
     * The unique identifier of the language in the context of the project.
     * @type {string}
     * @memberof UpdateLanguageModel
     */
    'key'?: string;
    /**
     * Long name of the language or any other description, deemed necessary by the managers of the project.
     * @type {string}
     * @memberof UpdateLanguageModel
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface UpdateProjectModel
 */
export interface UpdateProjectModel {
    /**
     * The name to identify your project, in the context of the localization server
     * @type {string}
     * @memberof UpdateProjectModel
     */
    'name'?: string;
    /**
     * Short description of the project
     * @type {string}
     * @memberof UpdateProjectModel
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface UpdateRoleModel
 */
export interface UpdateRoleModel {
    /**
     * The name to identify the role by.
     * @type {string}
     * @memberof UpdateRoleModel
     */
    'name'?: string;
    /**
     * The description of the nature of the role
     * @type {string}
     * @memberof UpdateRoleModel
     */
    'description'?: string;
    /**
     * The identifier of the rights the role should have
     * @type {Array<number>}
     * @memberof UpdateRoleModel
     */
    'rights'?: Array<number>;
}
/**
 * 
 * @export
 * @interface UpdateTranslationModel
 */
export interface UpdateTranslationModel {
    /**
     * The value of the translation
     * @type {string}
     * @memberof UpdateTranslationModel
     */
    'value'?: string;
    /**
     * Corresponding key.
     * @type {number}
     * @memberof UpdateTranslationModel
     */
    'keyId'?: number;
    /**
     * Corresponding language
     * @type {number}
     * @memberof UpdateTranslationModel
     */
    'languageId'?: number;
}
/**
 * 
 * @export
 * @interface UpdateUserModel
 */
export interface UpdateUserModel {
    /**
     * Your email to create the invite to.
     * @type {string}
     * @memberof UpdateUserModel
     */
    'email'?: string;
    /**
     * The user\'s first name.
     * @type {string}
     * @memberof UpdateUserModel
     */
    'fistName'?: string;
    /**
     * The user\'s last name.
     * @type {string}
     * @memberof UpdateUserModel
     */
    'lastName'?: string;
    /**
     * The user\'s password. Required if there is a new password present.
     * @type {string}
     * @memberof UpdateUserModel
     */
    'password'?: string;
    /**
     * The user\'s new password
     * @type {string}
     * @memberof UpdateUserModel
     */
    'newPassword'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'role'?: UserRoleEnum;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'disabled'?: boolean;
    /**
     * 
     * @type {Array<Project>}
     * @memberof User
     */
    'projects'?: Array<Project>;
    /**
     * 
     * @type {Array<Access>}
     * @memberof User
     */
    'access'?: Array<Access>;
    /**
     * 
     * @type {Array<Key>}
     * @memberof User
     */
    'keys'?: Array<Key>;
    /**
     * 
     * @type {Array<Translation>}
     * @memberof User
     */
    'translations'?: Array<Translation>;
    /**
     * 
     * @type {Array<Bundle>}
     * @memberof User
     */
    'issued'?: Array<Bundle>;
    /**
     * 
     * @type {Array<Bundle>}
     * @memberof User
     */
    'reviewed'?: Array<Bundle>;
    /**
     * 
     * @type {Array<Review>}
     * @memberof User
     */
    'reviews'?: Array<Review>;
    /**
     * 
     * @type {Array<Comment>}
     * @memberof User
     */
    'comments'?: Array<Comment>;
    /**
     * 
     * @type {Invite}
     * @memberof User
     */
    'invite'?: Invite;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'inviteId'?: number | null;
    /**
     * 
     * @type {Array<Invite>}
     * @memberof User
     */
    'invitations'?: Array<Invite>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum UserRoleEnum {
    User = 'USER',
    Po = 'PO',
    Hr = 'HR',
    Admin = 'ADMIN'
}

/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {number}
     * @memberof UserResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'firstName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'lastName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'role'?: UserResponseRoleEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UserResponse
     */
    'disabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserResponse
     */
    'inviteId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'createdAt'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum UserResponseRoleEnum {
    User = 'USER',
    Po = 'PO',
    Hr = 'HR',
    Admin = 'ADMIN'
}


/**
 * AccessApi - axios parameter creator
 * @export
 */
export const AccessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary delete a specific access
         * @param {number} id The id of the requested object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessIdDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accessIdDelete', 'id', id)
            const localVarPath = `/access/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create acces for a user to a project
         * @param {number} id The id of the requested object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessIdPost: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accessIdPost', 'id', id)
            const localVarPath = `/access/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create acces for a user to a project
         * @param {CreateAccessModel} createAccessModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessPost: async (createAccessModel: CreateAccessModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAccessModel' is not null or undefined
            assertParamExists('accessPost', 'createAccessModel', createAccessModel)
            const localVarPath = `/access/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAccessModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessApi - functional programming interface
 * @export
 */
export const AccessApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary delete a specific access
         * @param {number} id The id of the requested object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessIdDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create acces for a user to a project
         * @param {number} id The id of the requested object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessIdPost(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Access>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create acces for a user to a project
         * @param {CreateAccessModel} createAccessModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessPost(createAccessModel: CreateAccessModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Access>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accessPost(createAccessModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccessApi - factory interface
 * @export
 */
export const AccessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessApiFp(configuration)
    return {
        /**
         * 
         * @summary delete a specific access
         * @param {number} id The id of the requested object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessIdDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.accessIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create acces for a user to a project
         * @param {number} id The id of the requested object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessIdPost(id: number, options?: any): AxiosPromise<Access> {
            return localVarFp.accessIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create acces for a user to a project
         * @param {CreateAccessModel} createAccessModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessPost(createAccessModel: CreateAccessModel, options?: any): AxiosPromise<Access> {
            return localVarFp.accessPost(createAccessModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccessApi - object-oriented interface
 * @export
 * @class AccessApi
 * @extends {BaseAPI}
 */
export class AccessApi extends BaseAPI {
    /**
     * 
     * @summary delete a specific access
     * @param {number} id The id of the requested object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public accessIdDelete(id: number, options?: AxiosRequestConfig) {
        return AccessApiFp(this.configuration).accessIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create acces for a user to a project
     * @param {number} id The id of the requested object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public accessIdPost(id: number, options?: AxiosRequestConfig) {
        return AccessApiFp(this.configuration).accessIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create acces for a user to a project
     * @param {CreateAccessModel} createAccessModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApi
     */
    public accessPost(createAccessModel: CreateAccessModel, options?: AxiosRequestConfig) {
        return AccessApiFp(this.configuration).accessPost(createAccessModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Login
         * @param {LoginRequestModel} loginRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost: async (loginRequestModel: LoginRequestModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequestModel' is not null or undefined
            assertParamExists('authLoginPost', 'loginRequestModel', loginRequestModel)
            const localVarPath = `/auth/login/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register
         * @param {string} token The token of the invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterTokenGet: async (token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('authRegisterTokenGet', 'token', token)
            const localVarPath = `/auth/register/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register
         * @param {string} token The token of the invite
         * @param {RegisterRequestModel} registerRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterTokenPost: async (token: string, registerRequestModel: RegisterRequestModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('authRegisterTokenPost', 'token', token)
            // verify required parameter 'registerRequestModel' is not null or undefined
            assertParamExists('authRegisterTokenPost', 'registerRequestModel', registerRequestModel)
            const localVarPath = `/auth/register/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login
         * @param {number} id The id of the requested object
         * @param {LoginRequestModel} loginRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIdPost: async (id: number, loginRequestModel: LoginRequestModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createIdPost', 'id', id)
            // verify required parameter 'loginRequestModel' is not null or undefined
            assertParamExists('createIdPost', 'loginRequestModel', loginRequestModel)
            const localVarPath = `/create/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login
         * @param {LoginRequestModel} loginRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPost: async (loginRequestModel: LoginRequestModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequestModel' is not null or undefined
            assertParamExists('createPost', 'loginRequestModel', loginRequestModel)
            const localVarPath = `/create/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login
         * @param {LoginRequestModel} loginRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        socialPost: async (loginRequestModel: LoginRequestModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequestModel' is not null or undefined
            assertParamExists('socialPost', 'loginRequestModel', loginRequestModel)
            const localVarPath = `/social/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Login
         * @param {LoginRequestModel} loginRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLoginPost(loginRequestModel: LoginRequestModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLoginPost(loginRequestModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register
         * @param {string} token The token of the invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRegisterTokenGet(token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRegisterTokenGet(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register
         * @param {string} token The token of the invite
         * @param {RegisterRequestModel} registerRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRegisterTokenPost(token: string, registerRequestModel: RegisterRequestModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRegisterTokenPost(token, registerRequestModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login
         * @param {number} id The id of the requested object
         * @param {LoginRequestModel} loginRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIdPost(id: number, loginRequestModel: LoginRequestModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIdPost(id, loginRequestModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login
         * @param {LoginRequestModel} loginRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPost(loginRequestModel: LoginRequestModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPost(loginRequestModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login
         * @param {LoginRequestModel} loginRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async socialPost(loginRequestModel: LoginRequestModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.socialPost(loginRequestModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @summary Login
         * @param {LoginRequestModel} loginRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost(loginRequestModel: LoginRequestModel, options?: any): AxiosPromise<TokenModel> {
            return localVarFp.authLoginPost(loginRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register
         * @param {string} token The token of the invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterTokenGet(token: string, options?: any): AxiosPromise<Invite> {
            return localVarFp.authRegisterTokenGet(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register
         * @param {string} token The token of the invite
         * @param {RegisterRequestModel} registerRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterTokenPost(token: string, registerRequestModel: RegisterRequestModel, options?: any): AxiosPromise<TokenModel> {
            return localVarFp.authRegisterTokenPost(token, registerRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login
         * @param {number} id The id of the requested object
         * @param {LoginRequestModel} loginRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIdPost(id: number, loginRequestModel: LoginRequestModel, options?: any): AxiosPromise<User> {
            return localVarFp.createIdPost(id, loginRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login
         * @param {LoginRequestModel} loginRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPost(loginRequestModel: LoginRequestModel, options?: any): AxiosPromise<User> {
            return localVarFp.createPost(loginRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login
         * @param {LoginRequestModel} loginRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        socialPost(loginRequestModel: LoginRequestModel, options?: any): AxiosPromise<User> {
            return localVarFp.socialPost(loginRequestModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @summary Login
     * @param {LoginRequestModel} loginRequestModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authLoginPost(loginRequestModel: LoginRequestModel, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authLoginPost(loginRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register
     * @param {string} token The token of the invite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authRegisterTokenGet(token: string, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authRegisterTokenGet(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register
     * @param {string} token The token of the invite
     * @param {RegisterRequestModel} registerRequestModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authRegisterTokenPost(token: string, registerRequestModel: RegisterRequestModel, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authRegisterTokenPost(token, registerRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login
     * @param {number} id The id of the requested object
     * @param {LoginRequestModel} loginRequestModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public createIdPost(id: number, loginRequestModel: LoginRequestModel, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).createIdPost(id, loginRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login
     * @param {LoginRequestModel} loginRequestModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public createPost(loginRequestModel: LoginRequestModel, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).createPost(loginRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login
     * @param {LoginRequestModel} loginRequestModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public socialPost(loginRequestModel: LoginRequestModel, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).socialPost(loginRequestModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InvitesApi - axios parameter creator
 * @export
 */
export const InvitesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List invites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/invites/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary The id of the invitation to delete
         * @param {number} id The id of the invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitesIdDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('invitesIdDelete', 'id', id)
            const localVarPath = `/invites/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read invite by id
         * @param {number} id The id of the invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitesIdGet: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('invitesIdGet', 'id', id)
            const localVarPath = `/invites/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resend invite
         * @param {number} id The id of the invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitesIdResendPut: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('invitesIdResendPut', 'id', id)
            const localVarPath = `/invites/{id}/resend`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create invite
         * @param {CreateInviteModel} createInviteModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitesPost: async (createInviteModel: CreateInviteModel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createInviteModel' is not null or undefined
            assertParamExists('invitesPost', 'createInviteModel', createInviteModel)
            const localVarPath = `/invites/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createInviteModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvitesApi - functional programming interface
 * @export
 */
export const InvitesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvitesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List invites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invitesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invitesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary The id of the invitation to delete
         * @param {number} id The id of the invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invitesIdDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invitesIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Read invite by id
         * @param {number} id The id of the invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invitesIdGet(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invitesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Resend invite
         * @param {number} id The id of the invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invitesIdResendPut(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invitesIdResendPut(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create invite
         * @param {CreateInviteModel} createInviteModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invitesPost(createInviteModel: CreateInviteModel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invitesPost(createInviteModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InvitesApi - factory interface
 * @export
 */
export const InvitesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvitesApiFp(configuration)
    return {
        /**
         * 
         * @summary List invites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitesGet(options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.invitesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary The id of the invitation to delete
         * @param {number} id The id of the invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitesIdDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.invitesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read invite by id
         * @param {number} id The id of the invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitesIdGet(id: number, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.invitesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resend invite
         * @param {number} id The id of the invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitesIdResendPut(id: number, options?: any): AxiosPromise<Invite> {
            return localVarFp.invitesIdResendPut(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create invite
         * @param {CreateInviteModel} createInviteModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invitesPost(createInviteModel: CreateInviteModel, options?: any): AxiosPromise<Invite> {
            return localVarFp.invitesPost(createInviteModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvitesApi - object-oriented interface
 * @export
 * @class InvitesApi
 * @extends {BaseAPI}
 */
export class InvitesApi extends BaseAPI {
    /**
     * 
     * @summary List invites
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitesApi
     */
    public invitesGet(options?: AxiosRequestConfig) {
        return InvitesApiFp(this.configuration).invitesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary The id of the invitation to delete
     * @param {number} id The id of the invite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitesApi
     */
    public invitesIdDelete(id: number, options?: AxiosRequestConfig) {
        return InvitesApiFp(this.configuration).invitesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read invite by id
     * @param {number} id The id of the invite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitesApi
     */
    public invitesIdGet(id: number, options?: AxiosRequestConfig) {
        return InvitesApiFp(this.configuration).invitesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resend invite
     * @param {number} id The id of the invite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitesApi
     */
    public invitesIdResendPut(id: number, options?: AxiosRequestConfig) {
        return InvitesApiFp(this.configuration).invitesIdResendPut(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create invite
     * @param {CreateInviteModel} createInviteModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitesApi
     */
    public invitesPost(createInviteModel: CreateInviteModel, options?: AxiosRequestConfig) {
        return InvitesApiFp(this.configuration).invitesPost(createInviteModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a user
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdDelete', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Read user by id
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdGet', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sync me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TokenAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a user
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Read user by id
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdGet(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sync me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMeGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary List users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.usersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a user
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.usersIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Read user by id
         * @param {number} id The id of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdGet(id: number, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.usersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sync me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeGet(options?: any): AxiosPromise<UserResponse> {
            return localVarFp.usersMeGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary List users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGet(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a user
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdDelete(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Read user by id
     * @param {number} id The id of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdGet(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sync me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersMeGet(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersMeGet(options).then((request) => request(this.axios, this.basePath));
    }
}


